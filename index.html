<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Homotheties</title>

  <!-- Polices -->
  <link href="https://fonts.googleapis.com/css2?family=Androgy+Demo&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Mabry+Pro&display=swap" rel="stylesheet" />

  <style>
    :root{
      --primary:#5b6dfa; --secondary:#00bfa6; --accent:#ff6b6b;
      --bg:#f9f9f9; --grid:#dcdcdc; --text:#222;
      --radius:10px; --transition:0.25s;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:'Mabry Pro',sans-serif; background:var(--bg);
      color:var(--text); display:flex; flex-direction:column; align-items:center;
      padding:1.5rem; gap:1rem;
    }
    h1{
      font-family:'Androgy Demo',sans-serif; color:var(--primary); margin:0;
      font-size:2.2rem;
    }
    .controls {
      width: 100%; max-width: 900px; display:flex; gap:1rem; align-items:center;
      justify-content:space-between;
    }
    .panel {
      background:white; border-radius:var(--radius); padding:1rem; box-shadow:0 8px 18px rgba(0,0,0,0.08);
      width:100%; max-width:900px;
    }
    .question-text{ font-size:1.05rem; margin-bottom:0.5rem; color:#333 }
    #grid {
      width:600px; height:800px; background:white; border:2px solid var(--grid);
      border-radius:var(--radius); overflow:hidden; margin: 0 auto;
    }
    svg{ width:100%; height:100%; display:block; background:linear-gradient(#fff,#fff) }
    .btn{
      padding:0.6rem 1.1rem; border-radius:10px; border:none; cursor:pointer;
      background:var(--primary); color:white; font-weight:700; transition:all var(--transition);
    }
    .btn.secondary{ background:var(--secondary) }
    .small { padding:0.4rem 0.8rem; font-size:0.95rem; }
    .hint { font-size:0.92rem; color:#555; }
    .legend { display:flex; gap:0.75rem; align-items:center; }
    .dot{ width:12px; height:12px; border-radius:50% }
    .dot.orig { background:var(--primary) }
    .dot.O { background:black }
    .dot.user { background:var(--accent) }
    .status { font-weight:700; font-size:1rem; color:#444 }
    footer { width:100%; max-width:900px; display:flex; justify-content:flex-end; gap:0.5rem }
    @media (max-width:700px){
      #grid{ width:320px; height:426px } /* responsive */
    }
  </style>
</head>
<body>

  <h1>Homotheties</h1>

  <div class="panel controls">
    <div>
      <div class="question-text" id="qText">Chargement…</div>
  
    </div>
    
      <div class="status" id="status">Question 1 / 10</div>
    </div>
  </div>

  <div class="panel" style="display:flex;flex-direction:column;align-items:center;gap:1rem">
    <div id="grid"><svg id="svgGrid" viewBox="0 0 600 800" preserveAspectRatio="xMidYMid meet"></svg></div>

    <div style="display:flex;gap:0.6rem;flex-wrap:wrap;justify-content:center">
      <button class="btn small" id="checkBtn">Vérifier</button>
      <button class="btn small secondary" id="nextBtn">Question suivante</button>
      <button class="btn small" id="resetBtn" title="Tout recommencer">Réinitialiser</button>
    </div>
  </div>

  <footer>
    <div class="hint">Grille : 30 × 40 carrés — taille cellule = 20px</div>
  </footer>

<script>
/* --------- Configuration grille --------- */
const gridSize = 20;
const cols = 30;
const rows = 40;
const width = cols * gridSize; //600
const height = rows * gridSize; //800
const tol = 6; // tolérance px

/* --------- Questions (type, points, centre O, ratio k) - designs fit inside 30×40 */
const questions = [
  // 1 rectangle, k=1/2
  { type:'rectangle', label:'Construis A\',B\',C\',D\' l’image du rectangle ABCD par homothétie de centre O et de rapport 1/2.',
    O:{x:300,y:200}, pts:[{x:220,y:160},{x:300,y:160},{x:300,y:220},{x:220,y:220}], k:1/2 },
  // 2 triangle, k=2
  { type:'triangle', label:'Construis A\',B\',C\' l’image du triangle ABC par homothétie de centre O et de rapport 2.',
    O:{x:200,y:300}, pts:[{x:140,y:260},{x:180,y:340},{x:220,y:280}], k:2 },
  // 3 rectangle, k=3 (center near left to keep inside)
  { type:'rectangle', label:'Construis A\',B\',C\',D\' l’image du rectangle ABCD par homothétie de centre O et de rapport 3.',
    O:{x:120,y:100}, pts:[{x:160,y:120},{x:220,y:120},{x:220,y:180},{x:160,y:180}], k:3 },
  // 4 triangle, k=1/3
  { type:'triangle', label:'Construis A\',B\',C\' l’image du triangle ABC par homothétie de centre O et de rapport 1/3.',
    O:{x:420,y:150}, pts:[{x:360,y:120},{x:400,y:200},{x:440,y:140}], k:1/3 },
  // 5 rectangle, k=2
  { type:'rectangle', label:'Construis A\',B\',C\',D\' l’image du rectangle ABCD par homothétie de centre O et de rapport 2.',
    O:{x:320,y:420}, pts:[{x:260,y:360},{x:320,y:360},{x:320,y:400},{x:260,y:400}], k:2 },
  // 6 triangle, k=1/2
  { type:'triangle', label:'Construis A\',B\',C\' l’image du triangle ABC par homothétie de centre O et de rapport 1/2.',
    O:{x:200,y:520}, pts:[{x:160,y:480},{x:220,y:520},{x:190,y:560}], k:1/2 },
  // 7 rectangle, k=1/3
  { type:'rectangle', label:'Construis A\',B\',C\',D\' l’image du rectangle ABCD par homothétie de centre O et de rapport 1/3.',
    O:{x:480,y:520}, pts:[{x:420,y:480},{x:480,y:480},{x:480,y:540},{x:420,y:540}], k:1/3 },
  // 8 triangle, k=3
  { type:'triangle', label:'Construis A\',B\',C\' l’image du triangle ABC par homothétie de centre O et de rapport 3.',
    O:{x:100,y:660}, pts:[{x:140,y:640},{x:180,y:700},{x:120,y:720}], k:3 },
  // 9 rectangle, k=1/2
  { type:'rectangle', label:'Construis A\',B\',C\',D\' l’image du rectangle ABCD par homothétie de centre O et de rapport 1/2.',
    O:{x:360,y:660}, pts:[{x:300,y:620},{x:360,y:620},{x:360,y:700},{x:300,y:700}], k:1/2 },
  //10 triangle, k=2
  { type:'triangle', label:'Construis A\',B\',C\' l’image du triangle ABC par homothétie de centre O et de rapport 2.',
    O:{x:520,y:240}, pts:[{x:480,y:200},{x:520,y:280},{x:560,y:220}], k:2 }
];

/* --------- Setup svg & grid --------- */
const svg = document.getElementById('svgGrid');
svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

function drawGrid(){
  // thin grid lines
  for(let i=0;i<=cols;i++){
    const l = document.createElementNS(ns,'line');
    l.setAttribute('x1', i*gridSize); l.setAttribute('y1', 0);
    l.setAttribute('x2', i*gridSize); l.setAttribute('y2', height);
    l.setAttribute('stroke', '#eee'); l.setAttribute('stroke-width', 1);
    svg.appendChild(l);
  }
  for(let j=0;j<=rows;j++){
    const l = document.createElementNS(ns,'line');
    l.setAttribute('x1', 0); l.setAttribute('y1', j*gridSize);
    l.setAttribute('x2', width); l.setAttribute('y2', j*gridSize);
    l.setAttribute('stroke', '#eee'); l.setAttribute('stroke-width', 1);
    svg.appendChild(l);
  }
}

/* --------- Helpers --------- */
const ns = "http://www.w3.org/2000/svg";
function el(tag, attrs = {}){ const e = document.createElementNS(ns, tag); for(const k in attrs) e.setAttribute(k, attrs[k]); return e; }
function addText(x,y,t,cls){ const e=el('text',{x,y,'font-size':14}); e.textContent=t; svg.appendChild(e); return e; }
function drawPoint(p, color='var(--accent)', r=5, cls='user'){ const c=el('circle',{cx:p.x, cy:p.y, r, fill:color, stroke:'#000', 'stroke-width':0.6}); if(cls) c.classList.add(cls); svg.appendChild(c); return c; }
function drawPoly(pts, fill, stroke='#000'){ const poly=el('polygon',{points: pts.map(p=>`${p.x},${p.y}`).join(' '), fill, stroke, 'stroke-width':2, opacity:0.25}); svg.appendChild(poly); return poly; }
function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

/* --------- Interaction state --------- */
let current = 0;
let userPlaced = []; // array of points placed by student (in order)
let expected = []; // expected transformed points
let interactive = true;

/* --------- Compute homothety */ 
function homothetyPoint(O, P, k){
  return { x: Math.round((O.x + k * (P.x - O.x)) / gridSize) * gridSize,
           y: Math.round((O.y + k * (P.y - O.y)) / gridSize) * gridSize };
}

/* --------- Render one question --------- */
const qText = document.getElementById('qText');
const status = document.getElementById('status');
const checkBtn = document.getElementById('checkBtn');
const nextBtn = document.getElementById('nextBtn');
const resetBtn = document.getElementById('resetBtn');

function renderQuestion(idx){
  current = idx;
  userPlaced = [];
  interactive = true;
  clearSVG();
  drawGrid();

  const q = questions[idx];
  qText.textContent = q.label;
  status.textContent = `Question ${idx+1} / ${questions.length} — rapport ${q.k}`;

  // draw centre O
  const O = q.O;
  svg.appendChild(el('circle',{cx:O.x,cy:O.y,r:6,fill:'#000'}));
  const tO = el('text',{x:O.x+8,y:O.y-8,'font-size':14}); tO.textContent='O'; svg.appendChild(tO);

  // draw original figure and labels
  if(q.type === 'rectangle'){
    drawPoly(q.pts, 'var(--primary-color)');
    q.pts.forEach((p,i)=>{ drawPoint(p,'var(--primary-color)',5,'orig'); const t=el('text',{x:p.x+6,y:p.y-6,'font-size':13}); t.textContent=['A','B','C','D'][i]; svg.appendChild(t); });
  } else {
    drawPoly(q.pts, 'var(--primary-color)');
    q.pts.forEach((p,i)=>{ drawPoint(p,'var(--primary-color)',5,'orig'); const t=el('text',{x:p.x+6,y:p.y-6,'font-size':13}); t.textContent=['A','B','C'][i]; svg.appendChild(t); });
  }

  // compute expected transformed pts (snapped to grid)
  expected = q.pts.map(p => homothetyPoint(q.O, p, q.k));

  // Instruction text for order
  const order = (q.type==='rectangle') ? "Ordre attendu : A', B', C', D' (4 clics)" : "Ordre attendu : A', B', C' (3 clics)";
  document.getElementById('hint').textContent = `Clique pour placer ${ (q.type==='rectangle') ? "A', B', C', D' (dans cet ordre)" : "A', B', C' (dans cet ordre)" } — ${order}.`;

  // show little markers for expected (for teacher debugging you can uncomment)
  // expected.forEach((p,i)=> drawPoint(p,'rgba(0,0,0,0.08)',4));

}

/* --------- Click handler to place points (snapped to grid) --------- */
svg.addEventListener('click', function(e){
  if(!interactive) return;
  const rect = svg.getBoundingClientRect();
  // compute coords relative to viewBox scaling
  const viewBox = svg.viewBox.baseVal;
  const scaleX = viewBox.width / rect.width;
  const scaleY = viewBox.height / rect.height;
  const rawX = (e.clientX - rect.left) * scaleX;
  const rawY = (e.clientY - rect.top) * scaleY;
  const snappedX = Math.round(rawX / gridSize) * gridSize;
  const snappedY = Math.round(rawY / gridSize) * gridSize;

  const q = questions[current];
  const needed = (q.type === 'rectangle') ? 4 : 3;
  if(userPlaced.length >= needed) return;

  const p = {x:snappedX, y:snappedY};
  userPlaced.push(p);
  // draw small numbered point
  const label = (userPlaced.length).toString();
  const c = drawPoint(p,'var(--accent)',6,'user');
  const txt = el('text',{x:p.x+8,y:p.y-8,'font-size':12}); txt.textContent = label; svg.appendChild(txt);
});

/* --------- Verify answers --------- */
function checkAnswer(){
  if(!interactive) return;
  const q = questions[current];
  const needed = (q.type === 'rectangle') ? 4 : 3;
  if(userPlaced.length < needed){ alert(`Place ${needed} point(s) avant de vérifier !`); return; }

  // check each placed point against expected set but in the given order:
  // We consider matching by order: A' must match A2, B' match B2, etc.
  let allGood = true;
  const feedback = [];

  for(let i=0;i<needed;i++){
    const up = userPlaced[i];
    const exp = expected[i];
    const dx = Math.abs(up.x - exp.x);
    const dy = Math.abs(up.y - exp.y);
    const ok = (dx <= tol && dy <= tol);
    feedback.push({i, ok, up, exp});
    if(!ok) allGood = false;
  }

  // Visual feedback: color each user point border and draw expected points small
  feedback.forEach(f=>{
    // tiny marker for expected:
    const mark = el('circle',{cx:f.exp.x, cy:f.exp.y, r:6, fill:(f.ok? 'rgba(0,180,0,0.9)':'rgba(255,80,80,0.9)'), stroke:'#000', 'stroke-width':0.8 });
    svg.appendChild(mark);
    const txt = el('text',{x:f.exp.x+8,y:f.exp.y-8,'font-size':12}); txt.textContent = (f.i+1).toString(); svg.appendChild(txt);
  });

  // Draw polygon with color based on result (userPlaced polygon)
  const polyColor = allGood ? 'rgba(0,180,0,0.25)' : 'rgba(255,80,80,0.25)';
  drawPoly(userPlaced, polyColor, allGood ? 'green' : 'red');

  // Highlight each placed point stroke
  const placedCircles = svg.querySelectorAll('circle.user');
  placedCircles.forEach((c, idx)=>{
    const ok = feedback[idx] && feedback[idx].ok;
    c.setAttribute('fill', ok ? 'limegreen' : '#ff5b5b');
    c.setAttribute('stroke-width', 1.4);
  });

  interactive = false;
  if(allGood) alert("Bravo ✅ Tous les points sont corrects !");
  else alert("Il y a des erreurs ❌ — regarde les points verts/rouges et recommence si besoin.");
}

/* --------- Buttons --------- */
checkBtn.addEventListener('click', checkAnswer);
nextBtn.addEventListener('click', ()=>{
  const next = (current+1) % questions.length;
  renderQuestion(next);
});
resetBtn.addEventListener('click', ()=>{ renderQuestion(current); });

/* --------- Init --------- */
renderQuestion(0);

</script>
</body>
</html>
